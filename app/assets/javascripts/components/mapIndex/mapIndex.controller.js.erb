angular
  .module('mapHack')
  .controller('MapIndexController', MapIndexController);

MapIndexController.$inject = ['$http', 'cheatsService', '$window'];


function MapIndexController($http, cheatsService, $window) {
 	var vm = this;

    var map = [];

    vm.cheats = [];
    vm.currentUser = {};
    vm.userArray = [];
    vm.deleteCheat = deleteCheat;

    var cheatMarkersArray = [];

    onLoad();

    function onLoad() {
        cheatsService
            .getCheats()
            .then(function(res){
                console.log(res)
                vm.cheats = res.data.cheats;
                vm.currentUser = res.data.currentUser.id;
                vm.userArray = res.data.user_array;
                drawCheats(vm.cheats);
        });
    }

	initAutocomplete();

    function deleteCheat(cheat) {
        var id = cheat.id
        cheatsService
            .deleteCheat(id)
            .then(function(res){
                console.log('Your cheat has been deleted')
                $window.location.reload();
            })
    }


	function calculateRoute(from, to) {
        // Center initialized to Naples, Italy
        var myOptions = {
          zoom: 10,
          center: new google.maps.LatLng(40.84, 14.25),
          mapTypeId: google.maps.MapTypeId.ROADMAP
        };
        // Draw the map
        //var mapObject = new google.maps.Map(document.getElementById("map"), myOptions);

        var directionsService = new google.maps.DirectionsService();
        var directionsRequest = {
          origin: from,
          destination: to,
          travelMode: google.maps.DirectionsTravelMode.DRIVING,
          unitSystem: google.maps.UnitSystem.METRIC
        };
        directionsService.route(
          directionsRequest,
          function(response, status)
          {
            if (status == google.maps.DirectionsStatus.OK)
            {
              new google.maps.DirectionsRenderer({
                map: map,
                directions: response
              });
            }
            else
              $("#error").append("Unable to retrieve your route<br />");
          }
        );
    }

    function drawCheats(cheats) {
        cheats.forEach(function(cheat,index) {
            var latLng = {lat: cheat.start_point_lat, lng: cheat.start_point_long};
            console.log(latLng);
            var marker = new google.maps.Marker({
                position: latLng,
                map: map,
            });

            var infowindow = new google.maps.InfoWindow({
                content: "<div><a href=\"/cheat/" + cheat.id + "\">See This Hack</a></div>"
            });

            marker.addListener('click', function() {
                infowindow.open(map, marker);
            });

            cheatMarkersArray.push(marker);
        });
    }

    $(document).ready(function() {
    // If the browser supports the Geolocation API
        if (typeof navigator.geolocation == "undefined") {
            $("#error").text("Your browser doesn't support the Geolocation API");
            return;
        }

        $("#from-link, #to-link").click(function(event) {
            event.preventDefault();
            var addressId = this.id.substring(0, this.id.indexOf("-"));

            navigator.geolocation.getCurrentPosition(function(position) {
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    "location": new google.maps.LatLng(position.coords.latitude, position.coords.longitude)
                },
                function(results, status) {
                    if (status == google.maps.GeocoderStatus.OK)
                        $("#" + addressId).val(results[0].formatted_address);
                    else
                        $("#error").append("Unable to retrieve your address<br />");
                });
            },
            function(positionError){
                $("#error").append("Error: " + positionError.message + "<br />");
            },
            {
                enableHighAccuracy: true,
                timeout: 10 * 1000 // 10 seconds
            });
        });

        $("#calculate-route").submit(function(event) {
            event.preventDefault();
            calculateRoute($("#from").val(), $("#to").val());
        });
    });
	

	function initAutocomplete() {
        map = new google.maps.Map(document.getElementById('map'), {
            center: {lat: -33.8688, lng: 151.2195},
            zoom: 13,
            mapTypeId: 'roadmap'
        });

        // Create the search box and link it to the UI element.
        var input = document.getElementById('pac-input');
        var searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

        // Bias the SearchBox results towards current map's viewport.
        map.addListener('bounds_changed', function() {
            searchBox.setBounds(map.getBounds());
        });

        var markers = [];
        // Listen for the event fired when the user selects a prediction and retrieve
        // more details for that place.
        searchBox.addListener('places_changed', function() {
        var places = searchBox.getPlaces();
        if (places.length == 0) {
            return;
        }

        // Clear out the old markers.
        markers.forEach(function(marker) {
            marker.setMap(null);
        });
        markers = [];

        // For each place, get the icon, name and location.
        var bounds = new google.maps.LatLngBounds();
        places.forEach(function(place) {
        if (!place.geometry) {
            console.log("Returned place contains no geometry");
            return;
        }
        var icon = {
          url: place.icon,
          size: new google.maps.Size(71, 71),
          origin: new google.maps.Point(0, 0),
          anchor: new google.maps.Point(17, 34),
          scaledSize: new google.maps.Size(25, 25)
        };

        // Create a marker for each place.
        markers.push(new google.maps.Marker({
          map: map,
          icon: icon,
          title: place.name,
          position: place.geometry.location
        }));

        if (place.geometry.viewport) {
          // Only geocodes have viewport.
          bounds.union(place.geometry.viewport);
        } else {
          bounds.extend(place.geometry.location);
        }
        });
          map.fitBounds(bounds);
        });
      }

}